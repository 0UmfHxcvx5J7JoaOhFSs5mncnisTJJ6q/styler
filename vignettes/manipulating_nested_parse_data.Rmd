---
title: "Manipulating the nested Parse Table"
author: "Lorenz Walthert"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r, message=FALSE}
library("dplyr")
library("purrr")
```

This vignette builds on the vignette "Data Structures" and discusses how 
to go forward with the nested structure of the parse data.
In order to compute the white space information in a nested data structure, we
need a recursion. The function `create_filler_nested()` is used to add 
white space information on every level of nesting within the nested parse data.
```{r}
styler:::create_filler_nested
```
The function takes a nested parse table and uses `create_filler` to add two 
new columns "spaces" and "newlines" to the top-level tibble. Next, all entries
in the column "child" (i.e. the column that contains all remaining nested data) 
are modified in a recursive manner. Note that there is no need to unnest the 
tibble, add the information and re-nest it.
```{r}
code <- "a <- function(x) { if(x > 1) { 1+1 } else {x} }"
pd_nested <- styler:::compute_parse_data_nested(code)
pd_nested_enhanced <- styler:::create_filler_nested(pd_nested)
pd_nested_enhanced
```


As a next step, we need to find a way to serialize the nested tibble, or in 
other words, to transform it to its character vector representation. As a 
starting point, consider the function `serialize` that was introduced in the 
vignette "Data Structures". 

```{r}
serialize <- function(x) {
  out <- Map(
    function(terminal, text, child) {
      if (terminal)
        text
      else
        serialize(child)
    },
    x$terminal, x$text, x$child
  )
  out
}

serialize(pd_nested) %>% unlist
```

`serialize` can be combined with `serialize_parse_data_flat`. The latter
pastes together the column "text" of a flat parse table by taking into account
space and line break information, splits the string by line break and returns it.
```{r}
styler:::serialize_parse_data_flat
```


However, things get a bit more complicated, mainly because line break and white
space information is not only contained in the terminal tibbles of the nested
parse data, but even before, as the following example shows.
```{r}
pd_nested_enhanced$child[[1]]
pd_nested_enhanced$child[[1]]$child[[1]]
```
After "a" in `code`, there is a space, but this information is not contained in the
tibble where we find the terminal "a". In general, we must add newlines
and spaces values *after* we computed character vector representation of the 
expression. In our example: we know that there is a space after the non-terminal 
"a" by looking at `pd_nested_enhanced$child[[1]]`. Therefore, we need to add 
this space to the very last terminal within `pd_nested_enhanced$child[[1]]` before we 
collapse everything together.
```{r}
styler:::serialize_parse_data_nested_helper

styler:::serialize_parse_data_nested
```
Before we are done, we need to add information regarding indention to the parse
table. We can add indention after every line break that comes after a round 
braket with `indent_round()`. And then serialize it. 
```{r}
styler:::indent_round_nested(pd_nested_enhanced) %>%
  styler:::serialize_parse_data_nested()
```

We can see how indention works with a more complicated example
```{r}
indented <- c(
  "call(", 
  "  1,", 
  "  call2(", 
  "    2, 3,", 
  "    call3(1, 2, 22),", 
  "    5", 
  "  ),", 
  "  144",
  ")"
)

not_indented <- trimws(indented)
back_and_forth <- not_indented %>%
  styler:::compute_parse_data_nested() %>%
  styler:::create_filler_nested() %>%
  styler:::indent_round_nested() %>%
  styler:::serialize_parse_data_nested()

identical(indented, back_and_forth)
```

